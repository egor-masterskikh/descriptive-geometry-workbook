\startenvironment .
    \startMPinclusions[+]
    input mparrows;

    u := 1mm;

    base_line_thickness := .5u;  % толщина основной линии
    thin_line_thickness := base_line_thickness / 2;  % толщина тонкой линии

    pen base_pen, thin_pen;
    base_pen := pencircle scaled base_line_thickness;
    thin_pen := pencircle scaled thin_line_thickness;

    ahangle := 20;  % угол раствора стрелки
    ahlength := 4u;  % длина стрелки
    setarrows(open);

    path arrow_head;
    arrow_head := (-ahlength * cosd(ahangle / 2), ahlength * sind(ahangle / 2))--(0, 0)--(-ahlength * cosd(ahangle / 2), -ahlength * sind(ahangle / 2));

    arcs_distance := 1u;  % расстояние между соседними дужками в обозначении угла

    font_size := 5u;

    % диметрические трансформации
    transform cabinet_scaled_[], cabinet_slanted_[], cabinet_persp_[];

    cabinet_scaled_1 := identity yscaled (0.5 * cosd 45);
    cabinet_slanted_1 := identity slanted tand -45;
    cabinet_persp_1 := cabinet_scaled_1 transformed cabinet_slanted_1;

    cabinet_scaled_3 := identity xscaled (0.5 * cosd 45);
    cabinet_slanted_3 := identity rotated 90 slanted tand 45 rotated -90;
    cabinet_persp_3 := cabinet_scaled_3 transformed cabinet_slanted_3;
    
    picture gost_dashpattern;
    gost_dashpattern := dashpattern(off 1.2u on 3u);

    % точка-кружочек
    path point_circ;
    point_circ := fullcircle scaled u;

    def draw_point_circ(expr pos) =
        pickup thin_pen;
        if pair pos:
            fill point_circ shifted pos withcolor white;
            draw point_circ shifted pos;
        fi
    enddef;

    def draw_point_circ_with_label(expr pos, label_str)(suffix label_pos) =
        draw_point_circ(pos);
        label.label_pos(label_str, pos);
    enddef;

    def draw_axes(expr x_max, yi_max, z_max, yiii_max) =
        pair O, X, Z, Y[];

        O := (0, 0);
        X := (-x_max, 0);
        Z := (0, z_max);
        Y1 := (0, -yi_max);
        Y3 := (yiii_max, 0);

        path hor_axis, vert_axis;

        hor_axis := X--Y3;
        vert_axis := Y1--Z;

        pickup thin_pen;

        label.top("$X_{12}$", X);

        if (yi_max = 0) and (z_max = 0) and (yiii_max = 0):
            drawarrow reverse(hor_axis);
        else:
            drawdblarrow vert_axis;
            label.lft("$Y_1$", Y1);
            label.lft("$Z_{23}$", Z);

            if not (yiii_max = 0):
                drawdblarrow hor_axis;
                label.top("$Y_3$", Y3);
                label.ulft("\tf 0", O);
                
                pair k_endpoint;
                path k;
                k_endpoint := (1, -1) * (min(yiii_max, yi_max) - ahlength);
                k := O--k_endpoint;  % постоянная прямая чертежа
                draw k;
                if (yiii_max < yi_max):
                    label.bot("$k_0$", k_endpoint);
                else:
                    label.rt("$k_0$", k_endpoint);
                fi
            else:
                drawarrow reverse(hor_axis);
                label.rt("\tf 0", O);
            fi
        fi
    enddef;

    % numeric len -- длина отображаемого отрезка прямой
    % pair point_on -- точка, принадлежащая прямой
    % numeric point_on_k определяет, какую часть всего отрезка прямой составляет отрезок между начальной координатой отрезка и контрольной точкой
    % boolean return_val определяет, нужно ли возвращать значение начальной координаты
    vardef draw_line(expr len, direction, point_on, point_on_k, return_val) =
        save vec, start_point, end_point;
        pair vec, start_point, end_point;

        vec := len * direction;

        end_point - start_point = vec;
        point_on - start_point = point_on_k * vec;

        draw start_point--end_point withpen base_pen;

        if return_val:
            start_point
        fi
    enddef;

    % numeric label_k определяет, какую часть всего отрезка прямой составляет отрезок между начальной координатой отрезка и координатой метки
    % string label_str -- собственно содержимое метки
    % suffix label_pos -- расположение метки относительно её координаты
    vardef draw_line_with_label(expr len, direction, point_on, point_on_k, label_k, label_str)(suffix label_pos)(expr return_val) =
        save start_point;
        pair start_point;

        start_point := draw_line(len, direction, point_on, point_on_k, true);
        label.label_pos(label_str, start_point + label_k * len * direction);

        if return_val:
            start_point
        fi
    enddef;

    % pair a_vec, b_vec -- векторы, угол между которыми будет обозначен
    % numeric k -- отношение радиуса дуги к длине кратчайшего вектора
    % pair angle_point -- точка, около которой будет обозначен угол
    % numeric n -- количество дужек, обозначающих угол
    % boolean return_val определяет, нужно ли возвращать значение середины наибольшей дуги
    vardef mark_angle(expr a_vec, b_vec, k, angle_point, n, return_val) =
        save arc, start_r, end_r;
        path arc;

        arc := unitvector(a_vec){a_vec rotated 90}..unitvector(b_vec);

        start_r := k * min(length(a_vec), length(b_vec));
        end_r := start_r + arcs_distance * (n - 1);

        for cur_r = start_r step arcs_distance until end_r:
            draw arc scaled cur_r shifted angle_point;
        endfor

        if return_val:
            (point 0.5 of arc scaled end_r shifted angle_point)
        fi
    enddef;

    vardef mark_angle_with_label(expr a_vec, b_vec, k, angle_point, n, label_str) =
        save arc_mid_point, bisector, arc_r;
        pair arc_mid_point, bisector;

        arc_mid_point := mark_angle(a_vec, b_vec, k, angle_point, n, true);
        bisector := arc_mid_point - angle_point;
        arc_r := length(bisector);

        label(label_str, bisector * (1 + font_size / (2 * arc_r)) + angle_point);
    enddef;

    % pair A, B -- координаты точек, от которых будет сделан вынос
    % numeric extension_line_length -- длина выносной линии
    % numeric direction -- 1 или -1, определяет, в какую сторону относительно базовой линии будет сделан вынос
    % boolean return_val определяет, нужно ли возвращать размерную линию
    vardef draw_dimension_line(expr A, B, extension_line_length, direction, return_val) =
        save extension_line_vec, extension_line, dimension_line;

        pair extension_line_vec;
        extension_line_vec := unitvector(B - A) rotated (direction * 90) scaled extension_line_length;

        path extension_line;
        extension_line := O--extension_line_vec scaled (1 + 2 * ahlength * sind(ahangle / 2) / extension_line_length);

        draw extension_line shifted A;
        draw extension_line shifted B;

        path dimension_line;
        dimension_line := (A--B) shifted extension_line_vec;

        drawdblarrow dimension_line;

        if return_val:
            dimension_line
        fi
    enddef;

    % pair initial_point -- точка, от которой будет сделан вынос
    % numeric extension_angle -- угол, под которым будет выноситься полка
    vardef draw_extension_line(expr initial_point, extension_angle, label_str) =
        save extension_line, label_content, label_width, bar;

        pair extension_line_vec;
        extension_line_vec := dir extension_angle scaled font_size;

        path extension_line;
        extension_line := (O--extension_line_vec) shifted initial_point;

        picture label_content;
        label_content := thelabel.top(label_str, O);
        label_width := length((lrcorner label_content) - (llcorner label_content));

        pair bar_vec;
        if (-90 < extension_angle) and (extension_angle < 90):
            bar_vec := right * label_width;
        else:
            bar_vec := left * label_width;
        fi

        path bar_line;
        bar_line := (O--bar_vec) shifted (point 1 of extension_line);

        draw extension_line;
        draw bar_line;
        draw label_content shifted point 0.5 of bar_line;
    enddef;
    \stopMPinclusions
\stopenvironment