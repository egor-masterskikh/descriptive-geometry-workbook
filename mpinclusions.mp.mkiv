\startenvironment .
    \startMPinclusions[+]
    input mparrows;

    u := 1mm;

    base_line_thickness := .5u;  % толщина основной линии
    thin_line_thickness := base_line_thickness / 2;  % толщина тонкой линии

    pen base_pen, thin_pen;
    base_pen := pencircle scaled base_line_thickness;
    thin_pen := pencircle scaled thin_line_thickness;

    ahangle := 20;  % угол раствора стрелки
    ahlength := 4u;  % длина стрелки
    setarrows(open);

    path arrow_head;
    arrow_head := (-ahlength * cosd(ahangle / 2), ahlength * sind(ahangle / 2))--(0, 0)--(-ahlength * cosd(ahangle / 2), -ahlength * sind(ahangle / 2));

    % точка-кружочек
    path point_circ;
    point_circ := fullcircle scaled u;

    def draw_point_circ(expr pos) =
        pickup thin_pen;
        if pair pos:
            fill point_circ shifted pos withcolor white;
            draw point_circ shifted pos;
        fi
    enddef;

    def draw_point_circ_with_label(expr pos, label_str)(suffix label_pos) =
        draw_point_circ(pos);
        label.label_pos(label_str, pos);
    enddef;

    def draw_axes(expr x_max, yi_max, z_max, yiii_max) =
        pair O, X, Z, Y[];

        O := (0, 0);
        X := (-x_max, 0);
        Z := (0, z_max);
        Y1 := (0, -yi_max);
        Y3 := (yiii_max, 0);

        path hor_axis, vert_axis;

        hor_axis := X--Y3;
        vert_axis := Y1--Z;

        pickup thin_pen;

        label.top("$X_{12}$", X);

        if (yi_max = 0) and (z_max = 0) and (yiii_max = 0):
            drawarrow reverse(hor_axis);
        else:
            drawdblarrow vert_axis;
            label.lft("$Y_1$", Y1);
            label.lft("$Z_{23}$", Z);

            if not (yiii_max = 0):
                drawdblarrow hor_axis;
                label.top("$Y_3$", Y3);
                label.ulft("\tf 0", O);
                
                pair k_endpoint;
                path k;
                k_endpoint := (1, -1) * (min(yiii_max, yi_max) - ahlength);
                k := O--k_endpoint;  % постоянная прямая чертежа
                draw k;
                if (yiii_max < yi_max):
                    label.bot("$k_0$", k_endpoint);
                else:
                    label.rt("$k_0$", k_endpoint);
                fi
            else:
                drawarrow reverse(hor_axis);
                label.rt("\tf 0", O);
            fi
        fi
    enddef;

    % numeric len -- длина отображаемого отрезка прямой
    % pair point_on -- точка, принадлежащая прямой
    % numeric k определяет, какую часть всего отрезка прямой составляет отрезок между начальной координатой отрезка и контрольной точкой
    % boolean return_val определяет, нужно ли возвращать значение начальной координаты
    vardef draw_line(expr len, direction, point_on, point_on_k, return_val) =
        save vec, start_point, end_point;
        pair vec, start_point, end_point;

        vec := len * direction;

        end_point - start_point = vec;
        point_on - start_point = point_on_k * vec;

        draw start_point--end_point withpen base_pen;

        if return_val:
            start_point
        fi
    enddef;

    % numeric label_k определяет, какую часть всего отрезка прямой составляет отрезок между начальной координатой отрезка и координатой метки
    % string label_str -- собственно содержимое метки
    % suffix label_pos -- расположение метки относительно её координаты
    vardef draw_line_with_label(expr len, direction, point_on, point_on_k, label_k, label_str)(suffix label_pos)(expr return_val) =
        save start_point;
        pair start_point;

        start_point := draw_line(len, direction, point_on, point_on_k, true);
        label.label_pos(label_str, start_point + label_k * len * direction);

        if return_val:
            start_point
        fi
    enddef;
    \stopMPinclusions
\stopenvironment