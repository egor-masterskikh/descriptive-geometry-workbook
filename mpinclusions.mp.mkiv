\startenvironment .
    \startMPinclusions[+]
    input mparrows;

    u := 1mm;

    base_line_thickness := .5u;  % толщина основной линии
    thin_line_thickness := base_line_thickness / 2;  % толщина тонкой линии

    pen base_pen, thin_pen;
    base_pen := pencircle scaled base_line_thickness;
    thin_pen := pencircle scaled thin_line_thickness;

    ahangle := 20;  % угол раствора стрелки
    ahlength := 4u;  % длина стрелки
    setarrows(open);

    arrow_width := 2 * ahlength * sind(ahangle / 2);
    arrow_height := ahlength * cosd(ahangle / 2);

    path arrow_head;
    arrow_head := (-arrow_height, arrow_width / 2)--(0, 0)--(-arrow_height, -arrow_width / 2);

    arcs_distance := 1u;  % расстояние между соседними дужками в обозначении угла

    font_size := 3.5u;

    % диметрические трансформации
    transform cabinet_scaled_[], cabinet_slanted_[], cabinet_persp_[];

    cabinet_scaled_1 := identity yscaled (0.5 * cosd 45);
    cabinet_slanted_1 := identity slanted tand -45;
    cabinet_persp_1 := cabinet_scaled_1 transformed cabinet_slanted_1;

    cabinet_scaled_3 := identity xscaled (0.5 * cosd 45);
    cabinet_slanted_3 := identity rotated 90 slanted tand 45 rotated -90;
    cabinet_persp_3 := cabinet_scaled_3 transformed cabinet_slanted_3;
    
    picture gost_dashpattern;
    gost_dashpattern := dashpattern(off 1.2u on 3u);

    % точка-кружочек
    path point_circ;
    point_circ := fullcircle scaled u;

    def draw_point_circ(expr pos) =
        if pair pos:
            fill point_circ shifted pos withcolor white withpen thin_pen;
            draw point_circ shifted pos withpen thin_pen;
        fi
    enddef;

    def draw_point_circ_with_label(expr pos, label_str)(suffix label_pos) =
        draw_point_circ(pos);
        label.label_pos(label_str, pos);
    enddef;

    def draw_axes(expr x_max, yi_max, z_max, yiii_max) =
        pair O, X, Z, Y[];

        O := (0, 0);
        X := (-x_max, 0);
        Z := (0, z_max);
        Y1 := (0, -yi_max);
        Y3 := (yiii_max, 0);

        path hor_axis, vert_axis;

        hor_axis := X--Y3;
        vert_axis := Y1--Z;

        pickup thin_pen;

        label.top("$X_{12}$", X);

        if (yi_max = 0) and (z_max = 0) and (yiii_max = 0):
            drawarrow reverse(hor_axis);
        else:
            drawdblarrow vert_axis;
            label.lft("$Y_1$", Y1);
            label.lft("$Z_{23}$", Z);

            if not (yiii_max = 0):
                drawdblarrow hor_axis;
                label.top("$Y_3$", Y3);
                label.ulft("\tf 0", O);
                
                pair k_endpoint;
                path k;
                k_endpoint := (1, -1) * (min(yiii_max, yi_max) - ahlength);
                k := O--k_endpoint;  % постоянная прямая чертежа
                draw k;
                if (yiii_max < yi_max):
                    label.bot("$k_0$", k_endpoint);
                else:
                    label.rt("$k_0$", k_endpoint);
                fi
            else:
                drawarrow reverse(hor_axis);
                label.rt("\tf 0", O);
            fi
        fi
    enddef;

    % numeric len -- длина отображаемого отрезка прямой
    % pair point_on -- точка, принадлежащая прямой
    % numeric point_on_k определяет, какую часть всего отрезка прямой составляет отрезок между начальной координатой отрезка и контрольной точкой
    vardef get_line(expr len, inclination, point_on, point_on_k) =
        save vec, start_point, end_point;
        pair vec, start_point, end_point;

        vec := len * dir inclination;

        end_point - start_point = vec;
        point_on - start_point = point_on_k * vec;

        start_point--end_point
    enddef;

    % numeric label_k определяет, какую часть всего отрезка прямой составляет отрезок между начальной координатой отрезка и координатой метки
    % string label_str -- собственно содержимое метки
    % suffix label_pos -- расположение метки относительно её координаты
    vardef get_line_and_draw_label(expr len, inclination, point_on, point_on_k, label_k, label_str)(suffix label_pos) =
        save line; path line;
        line := get_line(len, inclination, point_on, point_on_k);
        label.label_pos(label_str, point label_k of line);
        line
    enddef;

    % pair a_vec, b_vec -- векторы, угол между которыми будет обозначен
    % pair angle_point -- точка, около которой будет обозначен угол
    % numeric k -- отношение радиуса дуги к длине кратчайшего вектора
    vardef get_angle_mark(expr a_vec, b_vec, angle_point, k) =
        save arc, r;
        path arc;

        r := k * min(length(a_vec), length(b_vec));
        arc := (unitvector(a_vec){a_vec rotated 90}..unitvector(b_vec)) scaled r;

        arc shifted angle_point
    enddef;

    vardef get_point_for_angle_label(expr arc, label_str) =
        save arc_midpoint, bisector, label_content, label_width, label_height, offset;
        pair arc_midpoint, bisector;

        arc_midpoint := point 0.5 of arc;
        bisector := unitvector(direction 0.5 of arc) rotated -90;

        picture label_content;
        label_content := thelabel(label_str, arc_midpoint);

        label_width := length((lrcorner label_content) - (llcorner label_content));
        label_height := length((ulcorner label_content) - (llcorner label_content));

        offset := 0.5 * length(label_width, label_height);

        if (-179 <= angle bisector) and (angle bisector <= -110)
           or (130 <= angle bisector) and (angle bisector <= 180):
            offset := offset + arcs_distance;
        fi

        arc_midpoint + bisector * offset
    enddef;

    vardef get_angle_mark_and_draw_label(expr a_vec, b_vec, angle_point, k, label_str) =
        save arc, point_for_angle_label;
        path arc;
        pair point_for_angle_label;

        arc := get_angle_mark(a_vec, b_vec, angle_point, k);
        point_for_angle_label := get_point_for_angle_label(arc, label_str);

        label(label_str, point_for_angle_label);

        arc
    enddef;

    vardef get_perp_mark(expr a_vec, b_vec, angle_point, k) =
        save mark, r;
        path mark;

        r := k * min(length(a_vec), length(b_vec));
        mark := (unitvector(a_vec)--(unitvector(a_vec) + unitvector(b_vec))--unitvector(b_vec)) scaled r;

        mark shifted angle_point
    enddef;

    % pair A, B -- координаты точек, от которых будет сделан вынос
    % numeric ext_line_len -- длина короткой выносной линии
    % numeric ext_angle -- угол, соответствующий направлению выноса относительно базовой линии
    % numeric dim_angle -- угол размерной линии относительно линии выноса
    vardef get_dim_line(expr A, B, ext_line_len, ext_angle, dim_angle) =
        save ext_line, dim_line, long_ext_line;

        pair ext_line_vec;
        ext_line_vec := unitvector(B - A) rotated ext_angle scaled ext_line_len;

        pair dim_line_vec;
        dim_line_vec := unitvector(ext_line_vec) rotated dim_angle scaled abs((B - A) * sind ext_angle / sind dim_angle);

        pair primary_point, secondary_point;

        if abs(ext_angle) <= 90:
            primary_point := B;
            secondary_point := A;
        else:
            primary_point := A;
            secondary_point := B;
        fi

        path dim_line, ext_line_[];

        dim_line := (O--dim_line_vec) shifted primary_point shifted ext_line_vec;
        ext_line_1 := (O--ext_line_vec) scaled (1 + arrow_width / ext_line_len) shifted primary_point;

        pair long_ext_line_vec;
        long_ext_line_vec := (point 1 of dim_line) - secondary_point;
        long_ext_line_len := length(long_ext_line_vec);

        ext_line_2 := (O--long_ext_line_vec) scaled (1 + arrow_width / long_ext_line_len) shifted secondary_point;

        draw ext_line_1;
        draw ext_line_2;

        dim_line
    enddef;

    % pair initial_point -- точка, от которой будет сделан вынос
    % numeric extension_angle -- угол, под которым будет выноситься полка
    vardef draw_extension_line(expr initial_point, extension_angle, label_str) =
        save extension_line, label_content, label_width, bar;

        pair extension_line_vec;
        extension_line_vec := dir extension_angle scaled (font_size + 2 * labeloffset);

        path extension_line;
        extension_line := (O--extension_line_vec) shifted initial_point;

        picture label_content;
        label_content := thelabel.top(label_str, O);
        label_width := length((lrcorner label_content) - (llcorner label_content));

        pair bar_vec;
        if (-90 < extension_angle) and (extension_angle < 90):
            bar_vec := right * label_width;
        else:
            bar_vec := left * label_width;
        fi

        path bar_line;
        bar_line := (O--bar_vec) shifted (point 1 of extension_line);

        draw extension_line;
        draw bar_line;
        draw label_content shifted point 0.5 of bar_line;
    enddef;

    % path trail -- путь
    % numeric arrow_k определяет, на какой части пути разместить стрелку
    vardef draw_path_with_arrow(expr trail, arrow_k) =
        drawarrow subpath(0, arrow_k) of trail;
        draw subpath(arrow_k, 1) of trail;
    enddef;
    \stopMPinclusions
\stopenvironment